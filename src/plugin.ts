import fs from 'node:fs';
import path from 'node:path';
import type { Compiler, RspackPluginInstance } from '@rspack/core';
import { assets } from './assets';

/**
 * Type of loading indicator to display
 * @public
 */
export type LoaderType = 'line' | 'dots' | 'spinner' | 'pulse' | 'orbit' | 'none';

/**
 * Configuration options for the Rspack Splash Screen Plugin
 * @public
 */
export type PluginOptions = {
  /**
   * Path to the logo image file relative to the public directory.
   * Supports SVG (inlined as markup) and raster formats (PNG, JPG, GIF, WebP, BMP - base64 encoded).
   * @example 'logo.svg' or 'images/logo.png'
   */
  logoSrc: string;

  /**
   * Background color of the splash screen overlay
   * @defaultValue '#ffffff'
   */
  splashBg?: string;

  /**
   * Color of the loading indicator
   * @defaultValue '#0072f5'
   */
  loaderBg?: string;

  /**
   * Type of loading indicator animation to display below the logo
   * @defaultValue 'line'
   */
  loaderType?: LoaderType;

  /**
   * Minimum duration (in milliseconds) to display the splash screen before allowing it to be hidden
   * @defaultValue 0
   */
  minDurationMs?: number;

  /**
   * Custom ID for the splash screen element and CSS classes. Useful for avoiding conflicts.
   * @defaultValue 'rpss'
   */
  id?: string;
};

/**
 * Rspack plugin that adds a splash screen to your application.
 * The splash screen is injected directly into the HTML at build time for optimal performance.
 *
 * @example
 * ```typescript
 * import { RspackSplashScreenPlugin } from 'rspack-plugin-splash-screen';
 *
 * export default {
 *   plugins: [
 *     new RspackSplashScreenPlugin({
 *       logoSrc: 'logo.svg',
 *       loaderType: 'spinner',
 *       minDurationMs: 1000
 *     })
 *   ]
 * };
 * ```
 *
 * @public
 */
export class RspackSplashScreenPlugin implements RspackPluginInstance {
  private options: Required<PluginOptions>;
  private publicDir: string;

  constructor(options: PluginOptions) {
    if (!options.logoSrc) {
      throw new Error('The `logoSrc` option is required for rspack-plugin-splash-screen!');
    }

    this.options = {
      logoSrc: options.logoSrc,
      minDurationMs: options.minDurationMs ?? 0,
      loaderType: options.loaderType ?? 'line',
      loaderBg: options.loaderBg ?? '#0072f5',
      splashBg: options.splashBg ?? '#ffffff',
      id: options.id ?? 'rpss'
    };

    this.publicDir = 'public'; // Default public directory
  }

  apply(compiler: Compiler) {
    const pluginName = 'RspackSplashScreenPlugin';

    // Hook into the compilation process to modify HTML assets
    compiler.hooks.make.tapAsync(pluginName, (compilation, callback) => {
      const { RawSource } = compiler.rspack.sources;
      const { Compilation } = compiler.rspack;

      compilation.hooks.processAssets.tapAsync(
        {
          name: pluginName,
          // Stage OPTIMIZE_INLINE + 1 ensures we run after HTML is generated by HtmlRspackPlugin
          // but before final optimizations. The +1 is necessary because HtmlRspackPlugin runs at
          // OPTIMIZE_INLINE stage, so we need to run immediately after it.
          stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE + 1
        },
        (assets, callback2) => {
          Object.keys(assets).forEach((assetName) => {
            if (!assetName.endsWith('.html')) {
              return;
            }

            const asset = assets[assetName];
            const html = asset.source().toString();
            const modifiedHtml = this.transformHtml(html);

            // Create a new RawSource with the modified content
            const source = new RawSource(modifiedHtml);

            // Update the asset in the compilation
            compilation.updateAsset(assetName, source);
          });

          callback2();
        }
      );

      callback();
    });
  }

  private transformHtml(html: string): string {
    const baseStyles = assets.stylesCSS;

    let loaderStyles = '';

    if (this.options.loaderType === 'line') {
      loaderStyles = assets.lineCSS;
    } else if (this.options.loaderType === 'dots') {
      loaderStyles = assets.dotsCSS;
    } else if (this.options.loaderType === 'spinner') {
      loaderStyles = assets.spinnerCSS;
    } else if (this.options.loaderType === 'pulse') {
      loaderStyles = assets.pulseCSS;
    } else if (this.options.loaderType === 'orbit') {
      loaderStyles = assets.orbitCSS;
    }

    // Resolve logo path - try multiple locations
    let logoHtml = '';
    const possiblePaths = [
      path.resolve(this.publicDir, this.options.logoSrc),
      path.resolve(process.cwd(), this.publicDir, this.options.logoSrc),
      path.resolve(process.cwd(), 'public', this.options.logoSrc)
    ];

    let foundLogoPath: string | null = null;
    for (const logoPath of possiblePaths) {
      if (fs.existsSync(logoPath)) {
        foundLogoPath = logoPath;
        break;
      }
    }

    if (foundLogoPath) {
      logoHtml = this.processLogo(foundLogoPath);
    } else {
      console.warn(
        `[rspack-plugin-splash-screen] Logo not found at any of: ${possiblePaths.join(', ')}`
      );
    }

    const splash = splashTemplate({
      logoHtml,
      loaderType: this.options.loaderType,
      minDurationMs: this.options.minDurationMs,
      id: this.options.id
    });

    // Only replace IDs in styles if the configured ID is different from the default 'rpss'
    let b = baseStyles.replace('/*BG_SPLASH*/', this.options.splashBg);
    let l = loaderStyles.replace('/*BG_LOADER*/', this.options.loaderBg);

    if (this.options.id !== 'rpss') {
      b = b.replace(/#rpss/g, `#${this.options.id}`).replace(/--rpss-/g, `--${this.options.id}-`);
      l = l.replace(/#rpss/g, `#${this.options.id}`).replace(/\.rpss-/g, `.${this.options.id}-`);
    }

    const styles = `<style id="${this.options.id}-style">${b}${l}</style>`;

    return (
      html
        // Add styles to end of head
        .replace('</head>', `${styles}</head>`)
        // Add splash screen to end of body
        .replace('</body>', `${splash}</body>`)
    );
  }

  private processLogo(logoPath: string): string {
    const ext = path.extname(logoPath).toLowerCase();
    const fileBuffer = fs.readFileSync(logoPath);
    const fileSizeKB = fileBuffer.length / 1024;

    // Recommended max size: 50KB for optimal splash screen performance
    const MAX_RECOMMENDED_SIZE_KB = 50;

    if (fileSizeKB > MAX_RECOMMENDED_SIZE_KB) {
      console.warn(
        `[rspack-plugin-splash-screen] Logo size (${fileSizeKB.toFixed(1)}KB) exceeds recommended maximum of ${MAX_RECOMMENDED_SIZE_KB}KB. ` +
          `This may slow down initial page load. Consider optimizing your logo image.`
      );
    }

    // SVG files can be inlined directly as text
    if (ext === '.svg') {
      return fileBuffer.toString('utf8');
    }

    // Non-SVG images need to be base64 encoded
    const mimeTypes: Record<string, string> = {
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.gif': 'image/gif',
      '.webp': 'image/webp',
      '.bmp': 'image/bmp'
    };

    const mimeType = mimeTypes[ext];
    if (!mimeType) {
      console.warn(
        `[rspack-plugin-splash-screen] Unsupported image format: ${ext}. ` +
          `Supported formats: SVG, PNG, JPG, JPEG, GIF, WebP, BMP.`
      );
      return '';
    }

    const base64Data = fileBuffer.toString('base64');
    return `<img src="data:${mimeType};base64,${base64Data}" alt="Logo" />`;
  }
}

function splashTemplate({
  logoHtml,
  loaderType,
  minDurationMs,
  id
}: {
  logoHtml: string;
  loaderType: LoaderType;
  minDurationMs?: number;
  id: string;
}) {
  /**
   * TODO: add more loader options.
   * Inspiration: https://cssloaders.github.io/
   */
  let loaderHtml = '';

  if (loaderType === 'line') {
    loaderHtml = assets.lineHTML;
  } else if (loaderType === 'dots') {
    loaderHtml = assets.dotsHTML;
  } else if (loaderType === 'spinner') {
    loaderHtml = assets.spinnerHTML;
  } else if (loaderType === 'pulse') {
    loaderHtml = assets.pulseHTML;
  } else if (loaderType === 'orbit') {
    loaderHtml = assets.orbitHTML;
  }

  // Only replace IDs in loader HTML if the configured ID is different from the default 'rpss'
  if (id !== 'rpss') {
    loaderHtml = loaderHtml.replace(/rpss-/g, `${id}-`);
  }

  return /*html*/ `
    <div id="${id}">
      <div class="${id}-logo">${logoHtml}</div>
      ${loaderHtml}
    </div>
    <script id="${id}-script">
      (function () {
        const id = "${id}";
        const url = new URL(window.location.href);
        const urlParams = new URLSearchParams(url.search)
        const param = urlParams.get(id);
        
        // Setup global options
        window.__RPSS__ = {
          id: id,
          hidden: param === "false",
          renderedAt: new Date().getTime(),
          minDurationMs: ${minDurationMs || 0},
          getElement: function() {
            return document.getElementById(id);
          },
          getStyles: function() {
            return document.getElementById(id + "-style");
          },
          getScript: function() {
            return document.getElementById(id + "-script");
          },
          show: function () {
            const element = this.getElement();
            if (!element) return;

            element.style.visibility = "visible";
          },
          hide: async function () {
            const element = this.getElement();
            if (!element) return;

            // Set hidden flag to prevent multiple calls
            this.hidden = true;

            // Optionally wait for minDurationMs before starting animation
            if (
              this.minDurationMs !== undefined &&
              this.renderedAt !== undefined
            ) {
              const elapsedTime = new Date().getTime() - this.renderedAt;
              const remainingTime = Math.max(this.minDurationMs - elapsedTime, 0);
              await new Promise((resolve) => setTimeout(resolve, remainingTime));
            }

            const animation = element.animate(
              [{ opacity: 1 }, { opacity: 0 }],
              { duration: 200, easing: "ease-out", fill: "forwards" }
            );

            animation.onfinish = () => {
              this.remove();
            };
          },
          remove: function () {
            const element = this.getElement();
            const styles = this.getStyles();
            const script = this.getScript();

            if (element) element.remove();
            if (styles) styles.remove();
            if (script) script.remove();
          }
        };

        if (window.__RPSS__.hidden) {
          window.__RPSS__.remove();
        } else {
          window.__RPSS__.show();
        }
        
        // Remove query param from URL
        if (param) {
          urlParams.delete(id);
          url.search = urlParams.toString();
          window.history.replaceState({}, "", url);
        }
      })();
    </script>
  `;
}
