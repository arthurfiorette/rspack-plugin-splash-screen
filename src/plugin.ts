import fs from "fs";
import path from "path";
import type { Compiler, Compilation, RspackPluginInstance } from "@rspack/core";

type LoaderType = "line" | "dots" | "none";

type PluginOptions = {
  logoSrc: string;
  splashBg?: string;
  loaderBg?: string;
  loaderType?: LoaderType;
  minDurationMs?: number;
};

export class RspackSplashScreenPlugin implements RspackPluginInstance {
  private options: Required<PluginOptions>;
  private publicDir: string;

  constructor(options: PluginOptions) {
    if (!options.logoSrc) {
      throw new Error(
        "The `logoSrc` option is required for rspack-plugin-splash-screen!"
      );
    }

    this.options = {
      logoSrc: options.logoSrc,
      minDurationMs: options.minDurationMs ?? 0,
      loaderType: options.loaderType ?? "line",
      loaderBg: options.loaderBg ?? "#0072f5",
      splashBg: options.splashBg ?? "#ffffff",
    };

    this.publicDir = "public"; // Default public directory
  }

  apply(compiler: Compiler) {
    const pluginName = "RspackSplashScreenPlugin";

    // Hook into the compilation process to modify HTML assets
    compiler.hooks.compilation.tap(pluginName, (compilation: Compilation) => {
      // Use PROCESS_ASSETS_STAGE_ADDITIONAL to run after HtmlPlugin generates the HTML
      // Stage 2000 ensures we run after the HTML has been generated by other plugins
      const stage = 2000;
      
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,
          stage: stage,
        },
        () => {
          const assets = compilation.getAssets();
          
          assets.forEach((asset) => {
            if (asset.name.endsWith('.html')) {
              const html = asset.source.source().toString();
              const modifiedHtml = this.transformHtml(html);
              
              // Update the asset with modified HTML
              // Note: Using 'as any' here is necessary as Rspack's internal source type
              // is not fully exported, but the interface matches what's expected
              compilation.updateAsset(asset.name, {
                source() { return modifiedHtml; },
                size() { return modifiedHtml.length; },
              } as any);
            }
          });
        }
      );
    });
  }

  private transformHtml(html: string): string {
    const baseStyles = readPluginFile("styles.css");

    let loaderStyles = "";

    if (this.options.loaderType === "line") {
      loaderStyles = readPluginFile("loaders/line.css");
    } else if (this.options.loaderType === "dots") {
      loaderStyles = readPluginFile("loaders/dots.css");
    }

    // Resolve logo path - try multiple locations
    let logoHtml = "";
    const possiblePaths = [
      path.resolve(this.publicDir, this.options.logoSrc),
      path.resolve(process.cwd(), this.publicDir, this.options.logoSrc),
      path.resolve(process.cwd(), "public", this.options.logoSrc),
    ];

    let foundLogoPath: string | null = null;
    for (const logoPath of possiblePaths) {
      if (fs.existsSync(logoPath)) {
        foundLogoPath = logoPath;
        break;
      }
    }

    if (foundLogoPath) {
      logoHtml = this.processLogo(foundLogoPath);
    } else {
      console.warn(
        `[rspack-plugin-splash-screen] Logo not found at any of: ${possiblePaths.join(", ")}`
      );
    }

    const splash = splashTemplate({
      logoHtml,
      loaderType: this.options.loaderType,
      minDurationMs: this.options.minDurationMs,
    });

    const b = baseStyles.replace("/*BG_SPLASH*/", this.options.splashBg);
    const l = loaderStyles.replace("/*BG_LOADER*/", this.options.loaderBg);

    const styles = `<style id="vpss-style">${b}${l}</style>`;

    return (
      html
        // Add styles to end of head
        .replace("</head>", `${styles}</head>`)
        // Add splash screen to end of body
        .replace("</body>", `${splash}</body>`)
    );
  }

  private processLogo(logoPath: string): string {
    const ext = path.extname(logoPath).toLowerCase();
    const fileBuffer = fs.readFileSync(logoPath);
    const fileSizeKB = fileBuffer.length / 1024;

    // Recommended max size: 50KB for optimal splash screen performance
    const MAX_RECOMMENDED_SIZE_KB = 50;

    if (fileSizeKB > MAX_RECOMMENDED_SIZE_KB) {
      console.warn(
        `[rspack-plugin-splash-screen] Logo size (${fileSizeKB.toFixed(1)}KB) exceeds recommended maximum of ${MAX_RECOMMENDED_SIZE_KB}KB. ` +
        `This may slow down initial page load. Consider optimizing your logo image.`
      );
    }

    // SVG files can be inlined directly as text
    if (ext === ".svg") {
      return fileBuffer.toString("utf8");
    }

    // Non-SVG images need to be base64 encoded
    const mimeTypes: Record<string, string> = {
      ".png": "image/png",
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".gif": "image/gif",
      ".webp": "image/webp",
      ".bmp": "image/bmp",
    };

    const mimeType = mimeTypes[ext];
    if (!mimeType) {
      console.warn(
        `[rspack-plugin-splash-screen] Unsupported image format: ${ext}. ` +
        `Supported formats: SVG, PNG, JPG, JPEG, GIF, WebP, BMP.`
      );
      return "";
    }

    const base64Data = fileBuffer.toString("base64");
    return `<img src="data:${mimeType};base64,${base64Data}" alt="Logo" />`;
  }
}

// Export a factory function for easier usage (similar to Vite plugin style)
export function splashScreen(options: PluginOptions) {
  return new RspackSplashScreenPlugin(options);
}

function splashTemplate({
  logoHtml,
  loaderType,
  minDurationMs,
}: {
  logoHtml: string;
  loaderType: LoaderType;
  minDurationMs?: number;
}) {
  /**
   * TODO: add more loader options.
   * Inspiration: https://cssloaders.github.io/
   */
  let loaderHtml = "";

  if (loaderType === "line") {
    loaderHtml = readPluginFile("loaders/line.html");
  } else if (loaderType === "dots") {
    loaderHtml = readPluginFile("loaders/dots.html");
  }

  return /*html*/ `
    <div id="vpss">
      <div class="vpss-logo">${logoHtml}</div>
      ${loaderHtml}
    </div>
    <script>
      (function () {
        const id = "vpss";
        const url = new URL(window.location.href);
        const urlParams = new URLSearchParams(url.search)
        const param = urlParams.get(id);
        
        // Setup global options
        window.__VPSS__ = {
          id: id,
          hidden: param === "false",
          renderedAt: new Date().getTime(),
          minDurationMs: ${minDurationMs || 0},
          getElement: function() {
            return document.getElementById(id);
          },
          getStyles: function() {
            return document.getElementById(id + "-style");
          },
          show: function () {
            const element = this.getElement();
            if (!element) return;

            element.style.visibility = "visible";
          },
          hide: async function () {
            const element = this.getElement();
            if (!element) return;

            // Set hidden flag to prevent multiple calls
            this.hidden = true;

            // Optionally wait for minDurationMs before starting animation
            if (
              this.minDurationMs !== undefined &&
              this.renderedAt !== undefined
            ) {
              const elapsedTime = new Date().getTime() - this.renderedAt;
              const remainingTime = Math.max(this.minDurationMs - elapsedTime, 0);
              await new Promise((resolve) => setTimeout(resolve, remainingTime));
            }

            const animation = element.animate(
              [{ opacity: 1 }, { opacity: 0 }],
              { duration: 200, easing: "ease-out", fill: "forwards" }
            );

            animation.onfinish = () => {
              this.remove();
            };
          },
          remove: function () {
            const element = this.getElement();
            const styles = this.getStyles();

            if (element && styles) {
              element.remove();
              styles.remove();
            }
          }
        };

        if (window.__VPSS__.hidden) {
          window.__VPSS__.remove();
        } else {
          window.__VPSS__.show();
        }
        
        // Remove query param from URL
        if (param) {
          urlParams.delete(id);
          url.search = urlParams.toString();
          window.history.replaceState({}, "", url);
        }
      })();
    </script>
  `;
}

// Resolve plugin files relative to this file's location
// Using __dirname for CommonJS or path resolution for ESM
function getPluginSrcPath(): string {
  // Try multiple resolution strategies to find the plugin source files
  const possiblePaths = [
    // Development/local link scenario
    path.resolve(__dirname, "."),
    path.resolve(__dirname, ".."),
    // Installed in node_modules
    path.resolve(process.cwd(), "node_modules/rspack-plugin-splash-screen/src"),
    path.resolve(process.cwd(), "node_modules/rspack-plugin-splash-screen/dist/plugin"),
    // pnpm with hoisting disabled
    path.resolve(__dirname, "../../rspack-plugin-splash-screen/src"),
  ];

  // Find the first path that contains the required files
  for (const basePath of possiblePaths) {
    const stylesPath = path.resolve(basePath, "styles.css");
    if (fs.existsSync(stylesPath)) {
      return basePath;
    }
  }

  // Fallback to __dirname
  return __dirname;
}

const pluginPath = getPluginSrcPath();

function readPluginFile(filePath: string) {
  return fs.readFileSync(path.resolve(pluginPath, filePath), "utf8");
}
